<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>17-Source Control - In Search of a Better</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="source-control---in-search-of-a-better-code-review">Source
Control - In Search of a Better Code Review</h1>
<h2
id="how-to-set-up-github-to-smooth-your-teams-development-process">How
to set up GitHub to smooth your team’s development process</h2>
<p>Source control is of vital importance in modern software development.
As a developer, you need to be confident that you can recover from
mistakenly deleting your code. It should be easy to create “what if”
experiments that are trivial to undo if necessary. Also, developers
rarely work alone. A good source control system make it convenient to
work with others and incorporate their changes into your code, and vice
versa.</p>
<p>There are plenty of opinions about the best way to handle code
reviews and pull requests on a software project. Some teams and
companies are very strict, requiring multiple levels of reviewers and
only a few people authorized to perform merges. Other teams are at the
opposite extreme, allowing anyone to merge their branches at any time
with no oversight whatsoever. In this article, I will propose something
in the middle.</p>
<h2 id="the-problem">The Problem</h2>
<p>In one of my projects, there were few developers and only a single
authorized code reviewer (ACR). The ACR was the only person with write
permissions to the protected branch, <code>develop</code> in our case.
Thus, he was the only person who could approve and merge feature
branches into <code>develop</code>. Interestingly, though the ACR was a
member of the team, he was not assigned any development responsibilities
on the project. He had responsibilities to other projects, so his time
was understandably dedicated to those projects primarily. The feature
development process had feature branches created and pushed to origin,
with pull requests following. At that point, the pull requests would
back up, waiting for days or sometimes even weeks to be reviewed.</p>
<p>There were not enough developers on this particular project to enlist
others to help with development or code reviews, and it got frustrating
quickly.</p>
<p>I decided to research a more efficient and effective process.</p>
<h2 id="goals-and-constraints">Goals and Constraints</h2>
<p>My goals are to reduce the time it takes for a pull request to be
opened, reviewed, and merged with our main development branch.</p>
<p>Some of my constraints are that code is hosted on an internal GitHub
instance in private repositories. This limits the pool of potential
reviewers.</p>
<h2 id="recommendation">Recommendation</h2>
<p>If you simply want to see my recommendation, you can read this
section and stop. The remainder of the article will be my supporting
arguments and reasoning which led me to this recommendation.</p>
<h2 id="development-work-flow">Development Work Flow</h2>
<p>This is a sample code flow I envision for any given feature:</p>
<ol type="1">
<li>A developer (Pat) is assigned a new feature.</li>
<li>Pat creates a new branch (FB) from the HEAD of the “main” branch (or
whatever it is called in your repository). Note: Pat does not fork the
repository, but has write access to it.</li>
<li>Pat implements the feature into FB, using as many commits as
necessary.</li>
<li>When complete, Pat pushes FB to origin and opens a pull
request.</li>
<li>Pushing FB automatically starts a build of FB, and the build status
is reported back to the repository.</li>
<li>If the build fails, the system will not permit FB to be merged.</li>
<li>The repo contains a <code>PULL_REQUEST_TEMPLATE.md</code> file,
which encourages consistency in pull request descriptions.</li>
<li>Pat requests that two or more peers review the pull request.</li>
<li>The “Code Owner” for the repository is automatically assigned to
review the pull request.</li>
<li>If any reviewer requests changes with the code review, Pat cannot
continue with the pull request until those changes are addressed.</li>
<li>Once the changes are addressed, Pat pushes new commits to FB, at
which time all existing reviews are dismissed, and the process begins
again.</li>
<li>If the main branch is updated while the pull request is open, Pat
must merge those changes into FB before it can be merged.</li>
<li>This cycle is repeated until all reviewers have approved, FB is
consistent with the main branch, and all builds of FB pass.</li>
<li>At this point, Pat is free to merge the pull request and delete
FB.</li>
</ol>
<h2 id="github-protected-branch-settings">GitHub Protected-branch
Settings</h2>
<p>Here is a description of my recommended settings for protecting the
base branch. Figure 17.1 shows them all together, after which I will
describe them in more detail.</p>
<figure>
<img src="image-15.png"
alt="Figure 17.1, My recommended GitHub Protected Branch Settings" />
<figcaption aria-hidden="true">Figure 17.1, My recommended GitHub
Protected Branch Settings</figcaption>
</figure>
<h2 id="the-rationale">The Rationale</h2>
<p>This section contains a more detailed explanation of the above
workflow.</p>
<h3 id="a-single-protected-branch">A Single Protected Branch</h3>
<p>I propose protecting a single branch, in our case the
<code>develop</code> branch, which is where all our feature branches get
merged into. This can be known as the “main” branch, the “base” branch,
etc. I use all three terms interchangeably.</p>
<h3 id="write-access-for-the-entire-team">Write Access for the Entire
Team</h3>
<p>In order for this recommendation to work effectively, each member of
the team must have write access to the repository. This enables a
feature branch to be created directly in the repository, rather than
forcing developers to fork the repository. The benefit is that code
reviewers can easily pull the feature branch onto their own machine for
testing (if necessary), instead of having to clone the forked
repository. Using forked repositories was common in the past, before the
introduction of protected branches. It still is common practice in open
source projects, where features can be contributed by virtually anyone.
In a corporate setting, the latter use case is unlikely.</p>
<h3 id="pull-request-with-template">Pull Request with Template</h3>
<p>Each repository should include a pull request template file (named
<code>PULL_REQUEST_TEMPLATE.md</code>) to help keep pull request
descriptions consistent between features and developers. At a minimum,
the template should prompt the developer for the following
information:</p>
<ul>
<li>A link to the “user story” or issue that the pull request
addresses.</li>
<li>A high level summary of the changes.</li>
<li>A quick start on how to build and test the branch. Remember, some
reviewers may be from another team and may not be intimately familiar
with the project.</li>
<li>What to look for in the application.</li>
</ul>
<h4 id="optional">Optional</h4>
<p>The pull request template may also contain prompts for these
items:</p>
<ul>
<li>Test and Linting results (though this can be managed by the status
checks).</li>
<li>Screenshots of the current implementation UI, if relevant.</li>
<li>Any additional context to help review and test the pull
request.</li>
</ul>
<h3 id="authorized-reviewers">Authorized Reviewers</h3>
<p>This is where things get interesting. I propose following the model
of an external company, <a
href="http://pullrequest.com">pullrequest.com</a>. They use code
reviewers who are completely removed from the project, and even the
company requesting the reviews. These reviewers provide a fresh
perspective unavailable from those doing active development on the
project. Such individuals need only read access to the repository.</p>
<p>The primary benefit to this is numbers. More potential reviewers
implies a faster time to first comment, which results in quicker pull
request turnaround.</p>
<p>In addition, every developer on the project should be an authorized
reviewer.</p>
<p>Given that all our reviewers have access to the corporate network, we
can take an additional step. We should allow and encourage our reviewers
to clone the repo, and then build and run the application from the
feature branch.</p>
<p>A useful side-effect of including reviewers from outside the
immediate team is that helps to avoid siloed knowledge. At any time in
the future, reviewers could potentially be tapped to join the project,
either temporarily or permanently, and not come into the project
blind.</p>
<h3 id="strict-status-checks">Strict Status Checks</h3>
<p>In our case, we are integrated with a Jenkins build pipeline. All
branches pushed to <code>origin</code> are built, code analysis is
performed, and all unit tests are run. The status of this build and test
phase are reported back to GitHub and the pull request containing that
branch. Before collaborators can merge changes into the protected
branch, this build must completely succeed.</p>
<h3 id="require-fb-to-be-up-to-date-with-the-main-branch">Require FB to
be up-to-date with the main branch</h3>
<p>The feature branch in a pull request will need to be up to date after
other collaborators merge pull requests to the protected base branch.
This puts the burden of merge conflicts onto the feature developer, the
person closest to the code and most likely to resolve them quickly.</p>
<h3 id="required-code-owner-review">Required Code Owner Review</h3>
<p>Each project should have one or more “code owners” who are not part
of the development team. They could be technical managers, development
leads from another project, or senior architects. The code owners are
specified by providing a <code>CODEOWNERS</code> file in the root folder
of the base branch. The interesting thing about this approach is that
different code owners can be assigned for different file types,
branches, etc. The details of whom to be assigned as code owner can be
determined by the project team.</p>
<p>The code owners’ responsibilities will not be to review the code in
detail, but simply to review the other reviews to ensure that they have
been completed satisfactorily. Once the appropriate code owners have
reviewed and approved the pull request, no additional reviews are
required.</p>
<h2
id="require-linear-history-use-squash-merges-from-feature-branches-to-main-branch">Require
Linear History (Use Squash Merges from Feature Branches to Main
Branch)</h2>
<p>This recommendation is all about reverting features in case problems
are discovered later. If a protected branch requires a linear history,
then only squash or rebase merges are permitted. I recommend the former.
When a squash merge is performed as part of a pull request, the entire
feature branch is merged into the base branch with a single commit.
While it is a “best practice” to make multiple commits during
development, this can lead to more difficult merge conflicts for
developers on other branches. Using a squash merge from a feature branch
to the base branch will reduce the feature to a single commit, making it
easier for other developers to pull those changes into their own feature
branches. It also helps in the event that the feature branch needs to be
reverted. Providing a single reverse commit can undo the entire pull
request, if it becomes necessary to remove a feature from an upcoming
release.</p>
<h2 id="merge-completed-by-code-author">Merge Completed by Code
Author</h2>
<p>When all reviews and status checks are complete, it is up to the
original feature branch author to perform the merge and delete the
feature branch if desired. Whether or not you delete feature branches is
a decision best left to the development team. I like deleting them and
keeping the origin clean, but some teams prefer to keep them around.</p>
<h2 id="what-about-automatic-merge">What about Automatic Merge?</h2>
<p>GitHub has an option to merge automatically once all other gates are
passed. I am tempted to recommend that, but I would only push for it if
it turns out the build/test/deploy cycle is too lengthy.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this has been helpful. You may or may not agree with some of
my suggestions, which is fine. What I hope to have impressed upon you is
that code review and pull request policies are flexible in GitHub. Your
team should discuss what will work best for your project based on your
developers’ experience and needs.</p>
<p>If nothing else, I hope you will have enough information to have the
conversation.</p>
</body>
</html>
