<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>11-RxJS - To Use or Not to Use</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="rxjs-to-use-or-not-to-use">RxJS – To Use or Not to Use?</h1>
<p>I am currently working on a project to uplift some AngularJS code to
Angular 10. On a recent code review there were some concerns that came
up about the heavy use of RxJS. I will attempt to address those concerns
in this chapter. Of particular note were the following assertions:</p>
<ul>
<li>RxJS is hard to learn/read.</li>
<li>RxJS is hard to test.</li>
</ul>
<h2 id="hard-to-learn">Hard to Learn</h2>
<p>Admittedly RxJS has a steep learning curve. That said, it should only
take a week or so to become accustomed to using it. Once you understand
the basics, the more esoteric operators are mostly a matter of finding
them. There is a great website that makes this easier, which is where I
found
the <code>fromEvent</code> and <code>combineLatest</code> operators I
use below. <a
href="https://rxjs.dev/operator-decision-tree">https://rxjs.dev/operator-decision-tree</a></p>
<h2 id="hard-to-test">Hard to Test</h2>
<p>Testing Angular is itself often an exercise in frustration. The key
is knowing what to test and what not to test, which is the subject of
another chapter in this book.</p>
<p>Some people go overboard and try to achieve 100% code coverage. I
have found that more than about 80-85% is usually counter-productive.
Often, people will write brittle (or worse, useless) tests to try to hit
some magical coverage number.</p>
<p>RxJS is no more difficult to test than Angular, assuming you write
your code to be testable in the first place. This is not always the
case, especially when you try to do too much with it at once. My
strategy is to create observables that do one thing that I can explain
in a comment. For example:</p>
<ul>
<li>Convert input event into stream of search terms.</li>
<li>Make web service call on selection change.</li>
</ul>
<p>These sorts of observables are reasonably straightforward to write
and test. More importantly, they are also straightforward to read and to
modify.</p>
<h2 id="the-code">The Code</h2>
<p>The code in question includes a custom dropdown with search
capability. The idea is that you can bind a very long list of items and
either select one or search for one by name. The component fires a
custom DOM event, <code>selected-changed</code>, to indicate that the
user has made a new selection.</p>
<p>The dropdown represents a list of “stores.” Whenever a store is
selected, the app needs to make a web request to load products
associated with that store.</p>
<p>Though it renders and behaves like an
HTML <code>&lt;select&gt;</code> tag, it does not actually contain
a <code>&lt;select&gt;</code> element. Fortunately, this turned out to
be irrelevant.</p>
<p>The first challenge was to figure out what event was being thrown.
The docs showed that I could
use <code>(selected-change)="storeChange($event)</code>, so I wired it
up to see what the event looks like. It seemed to be exactly what I had
hoped: a custom DOM event.</p>
<p>The next step was to create an Observable I could subscribe to. I
created a component variable I could use to subscribe to the event using
Angular’s <code>@ViewChild</code> decorator.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>@<span class="fu">ViewChild</span>(<span class="st">&#39;storeList&#39;</span>) storeListDropdown<span class="op">:</span> ElementRef<span class="op">;</span></span></code></pre></div>
<p>That led to this small bit of code:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="at">storeChanged$</span> <span class="op">=</span> <span class="fu">fromEvent</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">storeListDropdown</span><span class="op">.</span><span class="at">nativeElement</span><span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;selected-changed&#39;</span><span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">.</span><span class="fu">pipe</span>(</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tap</span>((x) <span class="kw">=&gt;</span> {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  })<span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>Now I could verify whether or not I could truly subscribe to these
custom events. A quick test showed that indeed I could. Hurdle one
cleared.</p>
<h2 id="make-the-service-call">Make the service call</h2>
<p>Next, I needed to take the newly-selected value and use it to make a
service call. For various reasons, I cannot show the actual call here,
but I think I can show enough to get my point across.</p>
<h3 id="i-only-care-about-selections">I only care about selections</h3>
<p>It is possible for the user to select nothing, at which point I do
not want to make a service call. So I added a filter to the observable’s
pipe to ensure I am only getting selections.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="at">storeChanged$</span> <span class="op">=</span> <span class="fu">fromEvent</span><span class="op">&lt;</span><span class="bu">CustomEvent</span><span class="op">&gt;</span>(</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">storeListDropdown</span><span class="op">.</span><span class="at">nativeElement</span><span class="op">,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;selected-changed&#39;</span><span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">.</span><span class="fu">pipe</span>(</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>((x) <span class="kw">=&gt;</span> x<span class="op">.</span><span class="at">detail</span><span class="op">?.</span><span class="at">value</span><span class="op">?.</span><span class="at">length</span>)<span class="op">,</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tap</span>((x) <span class="kw">=&gt;</span> {</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(x<span class="op">.</span><span class="at">detail</span><span class="op">.</span><span class="at">value</span>[<span class="dv">0</span>]<span class="op">.</span><span class="at">value</span>)<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  })<span class="op">,</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>With that I was able to confirm that it only fired when the user
selects something. There is another use case to clear the results if the
user selects nothing, but that is not currently important.</p>
<h2 id="making-the-web-call">Making the Web Call</h2>
<p>Next up was to make the web service call. I modified the
<code>tap</code> function to set a component variable that holds the
selection, then added a <code>switchMap</code> to call an Angular
service that hides the actual HTTP call. Now it looks like this:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="at">storeChanged$</span> <span class="op">=</span> <span class="fu">fromEvent</span><span class="op">&lt;</span><span class="bu">CustomEvent</span><span class="op">&gt;</span>(</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">storeListDropdown</span><span class="op">.</span><span class="at">nativeElement</span><span class="op">,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;selected-changed&#39;</span><span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">.</span><span class="fu">pipe</span>(</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>((x) <span class="kw">=&gt;</span> x<span class="op">.</span><span class="at">detail</span><span class="op">?.</span><span class="at">value</span><span class="op">?.</span><span class="at">length</span>)<span class="op">,</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tap</span>((x) <span class="kw">=&gt;</span> {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">selectedStore</span> <span class="op">=</span> x<span class="op">.</span><span class="at">detail</span><span class="op">.</span><span class="at">value</span>[<span class="dv">0</span>]<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  })<span class="op">,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">switchMap</span>((x) <span class="kw">=&gt;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">getProducts</span>(<span class="kw">this</span><span class="op">.</span><span class="at">selectedStore</span>)<span class="op">,</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  )<span class="op">,</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>I could drop the <code>tap</code> and do both the variable assignment
and the service call inside of the <code>switchMap</code> operator. I
may eventually do that, but for now I like the way that each step is
visually separated.</p>
<h2 id="implementing-a-search-filter">Implementing a Search Filter</h2>
<p>A single “store” in this project could return anywhere from 0 to
potentially hundreds or thousands of products. Each record is small, so
for now, we are keeping the filtering of products entirely client-side.
To support that, the UI has a search box. Entering anything in the
search box should cause the records to be filtered to those records
matching the value entered. This called for another observable, which I
will show in its entirety.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="at">searchFilterChanged$</span> <span class="op">=</span> <span class="fu">fromEvent</span><span class="op">&lt;</span><span class="bu">InputEvent</span><span class="op">&gt;</span>(</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">searchBox</span><span class="op">.</span><span class="at">nativeElement</span><span class="op">,</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;input&#39;</span><span class="op">,</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">.</span><span class="fu">pipe</span>(</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// tslint:disable-next-line: no-magic-numbers</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">debounceTime</span>(<span class="dv">300</span>)<span class="op">,</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>((_) <span class="kw">=&gt;</span> {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">searchFilter</span> <span class="op">=</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="at">searchBox</span><span class="op">.</span><span class="at">nativeElement</span><span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">searchFilter</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  })<span class="op">,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">distinctUntilChanged</span>()<span class="op">,</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">startWith</span>(<span class="st">&#39;&#39;</span>)<span class="op">,</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>As you can see, I start by creating an observable from the HTML
<code>input</code> event. That fires an event for every change to the
text box. This stream is then sent through another RxJS pipe to do the
following:</p>
<ul>
<li><p>The observable is “debounced” so that any value is delayed by
300ms. This prevents the events from coming in too fast as the user
types.</p></li>
<li><p>The <code>distinctUntilChanged</code> operator ensures that only
changes to the value are sent. In other words, if the user repeatedly
presses the space bar and the backspace key in rapid succession,
resulting in no change to the text box, my code will never see it. It is
unlikely, but possible.</p></li>
<li><p>Inside of <code>map</code>, I assign the value of the
<code>&lt;input&gt;</code> element to a component variable named
<code>searchFilter</code> and return that value. This successfully
converts the event into a string I can use as a search value
later.</p></li>
<li><p>The final operator is <code>startWith('')</code>, which will be
important later. This initializes the observable stream with an empty
string value.</p></li>
</ul>
<h2 id="pager-component">Pager Component</h2>
<p>My final component is another custom one that handles paging. As I
said, the results of the web service can potentially contain thousands
of records, so I want to provide a user a simple way of paging through
those results. Like my other custom component, it also fires
a <code>CustomEvent</code> called <code>nav-selected</code>. I again
used <code>fromEvent</code> and set it up similarly to the first
one.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="at">pagerChanged$</span> <span class="op">=</span> <span class="fu">fromEvent</span><span class="op">&lt;</span><span class="bu">CustomEvent</span><span class="op">&gt;</span>(</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">pager</span><span class="op">.</span><span class="at">nativeElement</span><span class="op">,</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&#39;nav-selected&#39;</span><span class="op">,</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>)<span class="op">.</span><span class="fu">pipe</span>(</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>((x) <span class="kw">=&gt;</span> x<span class="op">.</span><span class="at">detail</span><span class="op">.</span><span class="at">currentPage</span>)<span class="op">,</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">startWith</span>(<span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>This is the simplest of the bunch. Inside its pipe, I map the details
from the custom event into the page the user selected. Once again, I
start the stream with a default value.</p>
<h2 id="combine-them-all">Combine Them All</h2>
<p>Why did I go through all of this instead of simply using Angular
event binding? This is why.</p>
<p>Now that each event is its own individual stream of events, they can
easily be combined using the RxJS operator <code>combineLatest</code>.
This operator accepts an array of observables as its input and returns a
single observable. As its name implies, this observable fires when any
of its input observable values changes. Whenever that happens, the
subscriber gets the latest value of each of its constituent
observables.</p>
<p>The caveat for this operator is that it will not emit an event until
each observable in its input array has fired at least once. This is why
each of my observables above (except the first one)
used <code>startWith</code> to set an initial value. The store dropdown
did not need one because until the user selects a store, there is no
reason to do anything.</p>
<p>How does this all work in practice? Every time the user selects a new
store, changes the search filter, or selects a new page on the pager, my
subscriber gets the most recent value of each of those three
observables. Here is the code.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode typescript"><code class="sourceCode typescript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="at">filteredProducts$</span> <span class="op">=</span> <span class="fu">combineLatest</span>([</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">storeChanged$</span><span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">searchFilterChanged$</span><span class="op">,</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">pagerChanged$</span><span class="op">,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>])<span class="op">.</span><span class="fu">pipe</span>(</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map</span>(([products<span class="op">,</span> search<span class="op">,</span> page]) <span class="kw">=&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">filterProducts</span>(products<span class="op">,</span> search<span class="op">,</span> page)<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  )<span class="op">,</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p>Inside of the <code>map</code> operator, you can see that each value
from the array of observables is passed into its arrow function. I pass
those values into a pure function on my component
called <code>filterProducts</code>. This function handles the filter and
paging on the <code>products</code> array to return a new array of
products.</p>
<p>Keep in mind that the return of <code>combineLatest</code>, which is
assigned to <code>this.filteredProducts$</code>, is itself an
observable. This is important because of what happens next.</p>
<h2 id="inside-the-template">Inside the Template</h2>
<p>Because of the composition of these three independent observables
into a single observable, binding to its results is almost trivial.
Inside my HTML template, I have the following markup inside an
HTML <code>&lt;table&gt;</code> tag.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;tr</span> <span class="er">*ngFor</span><span class="ot">=</span><span class="st">&quot;let product of filteredProducts$ | async&quot;</span><span class="kw">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  ...</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">&lt;/tr&gt;</span></span></code></pre></div>
<p>By using Angular’s <code>async</code> pipe, I never need to subscribe
or unsubscribe to the observable. Angular handles all that for me.
Whenever any of the three source observables changes, the table will
update to reflect those changes.</p>
<h2 id="the-benefit-of-this-approach">The Benefit of This Approach</h2>
<p>I started down this path of using RxJS for user events because I
wanted to isolate each event and hide the irrelevant details from its
consumers. By using <code>fromEvent</code> I am able to tweak and modify
each event to get exactly the behavior I am looking for, separate from
the others.</p>
<p>With that, the final observable created
with <code>combineLatest</code> requires no additional manipulation. I
can pass the values to a pure function to get exactly the data to be
displayed, and then bind that data with a
simple <code>*ngFor</code> and <code>async</code> pipe.</p>
<p>Testing each observable stream independently from the others also
becomes almost trivial.</p>
<p>What I really like most about this approach, though, is how
extensible it is. When I first wrote this code, I only had the custom
dropdown and the text input box for searching. It was all working
properly when I decided to add the custom pager control. The result was
that I was able to include the pager, set up and test its custom event,
and then simply wire it up to the <code>combineLatest</code> operator by
adding it to the input array. Then I added it as an input to
my <code>filterProducts</code> function.</p>
<h2 id="what-do-others-think">What Do Others Think?</h2>
<p>I double-checked my philosophy with some people I consider experts,
both inside and outside of the team. Here are some of the responses I
received (mostly paraphrased):</p>
<ul>
<li>“That code is awesome!”</li>
<li>“For me it’s a tradeoff between simplicity (Angular’s event
bindings) and power (RxJS fromEvent). In the majority of cases, I only
need the simple event bindings. As soon as you try doing something
special (debounce, filter, delay, etc.), use RxJS.”</li>
<li>“Observables are a heavy pill to swallow. If you get why you’d use
it (sync/async feel the same, pure function pipelines of data,
deterministic, easier to unit test), cool. Otherwise, hide in the Model
layer so dev can play away from ’em elsewhere.”</li>
<li>“I struggled for a long time to understand RxJs (still don’t get
everything) but once I had a use case, it was a no-brainer to use the
library.”</li>
<li>“Every time I have to touch rxjs code it’s a major PITA and source
of bugs for me. I’m not intelligent enough to understand it, no matter
how many rxjs tutorials I read.”</li>
</ul>
<p>Interestingly, some suggested that learning to use state management
with NgRx might result in a lower learning curve than raw RxJS. My
experience has been the opposite.</p>
<p>Ultimately, I recommend that you use the best tool for the job. If
that means going a little outside of your comfort zone to learn RxJS, so
be it.</p>
<p>Everything you see above took about three days start-to-finish to get
right, including the unit tests I have not shown. When I began, I knew
almost nothing about any of these RxJS operators I ended up using.</p>
</body>
</html>
