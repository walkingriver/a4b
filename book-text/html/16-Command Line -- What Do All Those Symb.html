<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>16-Command Line -- What Do All Those Symb</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="command-line-what-do-all-those-symbols-mean">Command Line – What
Do All Those Symbols Mean?</h1>
<p><em>Do you know about all those weird symbols you can use on the
command line?</em></p>
<p>Even though you might spend most of your time in an interactive
development environment (IDE), it’s important to understand how to use
the command line.</p>
<p>Recently, I saw a tweet suggesting that if you place a single
ampersand between two shell commands, they run in parallel. While
partially true, the tweet didn’t fully explain the whole scenario. So, I
thought of revisiting the basics and explaining just what these and
other symbols do in a Linux, MacOS, or even Windows (Bash) terminal.</p>
<p>This is the tweet I referred to:</p>
<blockquote>
<p><em>Did you know that a double ampersand &amp;&amp; will run multiple
scripts sequentially while a single &amp; will run them in
parallel?</em><br />
<em>— Dan Vega (<span class="citation"
data-cites="therealdanvega">@therealdanvega</span>) April 11,
2019</em></p>
</blockquote>
<p><strong>Note</strong>: The examples contained below were all tested
and work on a macOS terminal running the bash shell. They should work on
any other common shell in Linux, and should even work in GitBash for
Windows. As always, your mileage may vary.</p>
<h2 id="and">And <code>&amp;&amp;</code></h2>
<p>Most developers are familiar with this example, especially when
dealing with build scripts. For example:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> test <span class="kw">&amp;&amp;</span> <span class="ex">npm</span> run build</span></code></pre></div>
<p>The common understanding is that this command
runs <code>npm test</code> and then <code>npm run build</code>. But
that’s not quite right. It’s more accurate to say that it runs
<code>npm test</code>, and only if <code>npm run</code> succeeds (exit
code is 0), will it run <code>npm run build</code>. If the first command
fails (exit code != 0), then the second command won’t run at all. This
is typically the behavior you’d want. For instance, in this example, if
the tests fail, there is no reason to run the build.</p>
<p>To validate this, try the following in your terminal:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> this-folder-does-not-exist-anywhere <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;I will not execute&quot;</span></span></code></pre></div>
<p>You should see an error message, and the echoed string will not
appear. You can chain as many commands as you like using
<code>&amp;&amp;</code>, just remember that the first command that fails
will interrupt the rest.</p>
<h2 id="or">Or <code>||</code></h2>
<p>What if you want the sequence of commands to continue regardless? You
might try using the Or (<code>||</code>) operator, but that probably
won’t work the way you think. While the <code>&amp;&amp;</code> operator
terminates after the first failure, <code>||</code> terminates after the
first success. So, the second command will only run if the first command
fails!</p>
<p>Here’s a demonstration:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;I worked&quot;</span> <span class="kw">||</span> <span class="bu">echo</span> <span class="st">&quot;Which means I will not execute&quot;</span></span></code></pre></div>
<p>This construct is often used as a simple test mechanism before
creating a file or folder. Consider this example:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">[</span> <span class="ot">-d</span> ~/i-do-not-exist <span class="bu">]</span> <span class="kw">||</span> <span class="fu">mkdir</span> ~/i-do-not-exist</span></code></pre></div>
<p>The first command tests whether a directory exists. Thus, the entire
command says, “make this directory, but only if it does not already
exist.” This method avoids writing an error to the terminal, unlike
using <code>ls ~/i-do-not-exist</code>.</p>
<h2 id="my-home-folder">My Home Folder <code>~</code></h2>
<p>If you’re unfamiliar with the tilde <code>~</code> symbol from the
previous example, it’s a handy shortcut representing your home
directory. Here’s how to expand it using the <code>echo</code>
command:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> ~</span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">/Users/michael</span></span></code></pre></div>
<h2 id="background">Background <code>&amp;</code></h2>
<p>Let’s return to the tweet suggesting that a single <code>&amp;</code>
allows the commands to run in parallel. While true, it doesn’t tell the
whole story. Generally, you’d use the <code>&amp;</code> operator when
you want a long-running shell script to execute in the background. Sure,
you could open another terminal session, but that would use more
resources.</p>
<p>Here’s an example of a long-running command that searches for all PDF
files in my home directory, writing each file’s path into a text file
named <code>my-pdf-files.txt</code>.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt</span></code></pre></div>
<p>On my i7 MacBook Pro, this command takes over 2.5 minutes to execute.
Adding the <code>&amp;</code> operator to the end of that command causes
it to run as a background job, allowing you to continue with other
tasks.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="kw">&amp;</span></span></code></pre></div>
<p>On execution, you get an immediate response like this:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[1]</span> 35715</span></code></pre></div>
<p>This output indicates that my background job is Job #1, and its
process ID is 35715. You can check its status with the <code>jobs</code>
command.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">jobs</span></span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[1]+</span> Running find ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="kw">&amp;</span></span></code></pre></div>
<p>You can bring it to the foreground with the <code>fg 1</code>
command, which blocks your terminal. Once in the foreground, you can
suspend the job by typing <code>Ctrl+Z</code>, and then typing
<code>bg</code> to send it back to the background.</p>
<p>To terminate the process, use the <code>kill 35715</code> command
(the process ID from initial command’s output).</p>
<p>How does this work with two commands? If the two commands are related
to each other, it probably won’t work well. But, if I want to run two
similar <code>find</code> commands, one looking for PDFs and another for
MP3 files, they can run in parallel as it doesn’t matter which one
completes first.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="kw">&amp;</span> <span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.mp3 <span class="op">&gt;</span> ~/my-mp3-files.txt <span class="kw">&amp;</span></span></code></pre></div>
<p>Output:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[1]</span> 36782</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ex">[2]</span> 36783</span></code></pre></div>
<p>This command creates two background jobs, indicated by the two job
numbers and process IDs provided. When they complete, your terminal will
display something like this:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">[1]-</span> Exit 1 find ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ex">[2]+</span> Exit 1 find ~ <span class="at">-name</span> <span class="pp">*</span>.mp3 <span class="op">&gt;</span> ~/my-mp3-files.txt</span></code></pre></div>
<h2 id="redirect-output">Redirect Output <code>&gt;</code></h2>
<p>If you have been following along with these examples, you may have
seen a few error messages. Even though the commands are running in the
background, the output of both is being displayed at the terminal. That
is easy enough to fix, by redirecting its output, using the “greater
than” or “right angle bracket” symbol (<code>&gt;</code>). In fact, I
used that in the previous two examples.</p>
<p>Using a single <code>&gt;</code> symbol tells the shell to redirect
the standard console output (stdout) to the file specified. So the
<code>find</code> command above sends its standard output to the file.
If the file does not exist, it will be created. If it does exist, it
will be replaced.</p>
<p>If you want the command to append to the file instead of creating it
from scratch, you can use two <code>&gt;&gt;</code> symbols.</p>
<p>None of that prevents errors from being displayed on the console,
because that is a different output stream (known as stderr). You have a
couple of alternatives here. You can send the errors into a different
file, by specifying another redirect, like this.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="dv">2</span><span class="op">&gt;</span>~/errors.txt</span></code></pre></div>
<p>The <code>2&gt;</code> specifically indicates that you are
redirecting <code>stderr</code>. As you might guess, <code>1&gt;</code>
indicates <code>stdout</code>, but the default redirect is
<code>stdout</code>, so the <code>1</code> can be omitted.</p>
<p>Further complicating things, you can redirect <code>stderr</code> to
the same target as <code>stdout</code>, by using <code>&amp;1</code> as
its target, like this…</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="dv">2</span><span class="op">&gt;&amp;</span><span class="dv">1</span></span></code></pre></div>
<p><code>&amp;1</code>, another example of <code>&amp;</code> that means
something else entirely, is shortcut for “where <code>stdout</code> is
being sent.”</p>
<p>I do not often have occasion for <code>stdout</code> and
<code>stderr</code> to end up in the same file, particularly in the
above examples, where I am collecting files of a certain type into a
file of those files. In those scenarios, I would prefer simply to throw
those errors away.</p>
<p>In MacOS or Linux shells, I can choose to redirect
<code>stderr</code> to <code>/dev/null</code>, a special file that
simply ignores everything. On Windows, I understand there is a special
file called <code>nul</code> that accomplishes the same thing.</p>
<p>So my complete command above will look like this.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="dv">2</span><span class="op">&gt;</span>/dev/null</span></code></pre></div>
<h2 id="redirect-input">Redirect Input <code>&lt;</code></h2>
<p>I see this used less often, as most commands accept the name of an
input file as an argument. Back in the day™, many (if not most) commands
operated on standard input (stdin), by default, the keyboard, and sent
its output to <code>stdout</code>.</p>
<p>Imagine I want to know how many of those PDF files above were found.
I could open the file in my favorite text editor and check, but there is
an easier way. I can type this command in the terminal.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">wc</span> <span class="at">-l</span> <span class="op">&lt;</span> ~/my-pdf-files.txt</span></code></pre></div>
<p>Result:</p>
<pre><code>3308</code></pre>
<p>Yeah, I had no idea I have that many. <code>wc</code> is the “word
count” command, and the <code>-l</code> switch tells it I only care
about the number of lines. By default, <code>wc</code> takes its input
from <code>stdin</code>, which you can see by typing the command by
itself, entering any text you want, ending your input by typing
<code>Ctrl+D</code>.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">wc</span> <span class="at">-l</span></span></code></pre></div>
<p>Input:</p>
<pre><code>Mike
was
here
Ctrl+D</code></pre>
<p>Result:</p>
<pre><code>3</code></pre>
<p>Notice that the <code>Ctrl+D</code> isn’t counted as a line. It also
needs to be specified on a line by itself. If you type it at the end of
a line, it will be part of that line.</p>
<p>This strategy works with any command that accepts input from
<code>stdin</code>, which is most commands available in the
terminal.</p>
<p>One command I see most often is <code>more</code>, which is used to
page the output of a file.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">more</span> <span class="op">&lt;</span> ~/my-pdf-files.txt</span></code></pre></div>
<p>Again, I do not see this used much anymore; most of these commands
accept the file to be operated on as an argument. This version of the
command is far more common.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">more</span> ~/my-pdf-files.txt</span></code></pre></div>
<h2 id="io-pipe">I/O Pipe <code>|</code></h2>
<p>What about the single <code>|</code> operator? This is an I/O Pipe.
It uses the output of the first command as input to the second command.
Think of this as a combination of both <code>&gt;</code> and
<code>&lt;</code>.</p>
<p>What if I wanted a sorted list of those PDF files? I could use the
<code>sort</code> command after the fact. However, I could also use the
<code>|</code> pipe as part of the <code>find</code> command, ignoring
errors, sorting the output, finally depositing the information in a new
file, executing the entire thing as a background job.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">find</span> ~ <span class="at">-name</span> <span class="pp">*</span>.pdf <span class="dv">2</span><span class="op">&gt;</span>/dev/null <span class="kw">|</span> <span class="fu">sort</span> <span class="op">&gt;</span> ~/my-pdf-files.txt <span class="kw">&amp;</span></span></code></pre></div>
<h2 id="expand">Expand $</h2>
<p>Every system has environment variables. These are settings specific
to the running system. On my Mac, I have more than 100 of them. If you
need to use them inside of a shell script or another command, they can
be convenient to know about, even when they have a command
equivalent.</p>
<p>For example, I mentioned ~ above. You can also reference that with
the $HOME environment variable. On my system, I also have things
like $HOSTNAME, $USER.</p>
<p>The outputs of these commands are often used inside of other
commands.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> My home directory is <span class="dt">\~</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> My home directory is <span class="dt">\$</span>HOME</span></code></pre></div>
<p>A very common use of this is to see what folders on your system are
searched for executable files. This is allows you to type java
-version instead of its absolute path, which would be much longer and
more inconvenient to type.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="dt">\$</span>PATH</span></code></pre></div>
<h2 id="expansion-within">Expansion within " "</h2>
<p>The echo command above is special. It can handle multiple parameters.
Most commands prefer you to surround a string like that in quotes, to be
considered a single parameter. In that case, it is important to know the
difference between single quotes (') and double quotes (").</p>
<p>When you use double quotes, your environment variables will be
expanded.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="dt">\&quot;</span>Hi, <span class="dt">\$</span>USER! Have you cleaned up your <span class="dt">\$</span>HOME folder today<span class="pp">?</span><span class="dt">\&quot;</span></span></code></pre></div>
<p>Output:</p>
<pre><code>Hi, michael! Have you cleaned up your /Users/michael folder today?</code></pre>
<p>In this command, the $USER and $HOME variables are both expanded. The
entire string is passed as a single parameter to the echo command.</p>
<h2 id="no-expansion-within">No Expansion within ' '</h2>
<p>If you do not want the environment variables to be expanded, you can
use single quotes instead (').</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="dt">\&#39;</span>Hi, <span class="dt">\$</span>USER! Have you cleaned up your <span class="dt">\$</span>HOME folder today<span class="pp">?</span><span class="dt">\&#39;</span></span></code></pre></div>
<p>Output:</p>
<pre><code>Hi, \$USER! Have you cleaned up your \$HOME folder today?</code></pre>
<h2 id="use-command-output">Use Command Output ``</h2>
<p>What if you want to execute a command and include its output as part
of another command? For that, you can surround the command with
back-ticks (`). This is different from output piping, as it is not
necessarily redirecting the output of one command as the input to
another command. Consider this overly simplistic example.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="dt">\&quot;</span>You have <span class="dt">\`</span>wc <span class="at">-l</span> <span class="dt">\&lt;</span> <span class="dt">\~</span>/my-pdf-files.txt\` PDF files.<span class="dt">\&quot;</span></span></code></pre></div>
<p>Output:</p>
<pre><code>You have 3308 PDF files.</code></pre>
<p>The wc command is executed, its output is placed into the string at
that point, and then the entire string is passed to
the echo command.</p>
<p>Another place I use this pattern often is trying to find the actual
location of an executable. On my Mac, most executables are symbolically
linked into the /usr/bin folder. So this command does not provide the
information I need.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">which</span> java</span></code></pre></div>
<p>Output:</p>
<pre><code>java is /usr/bin/java</code></pre>
<p>To know where it really is, I will use the ls -l command on the
output of the which java command, like so.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> <span class="at">-l</span> <span class="dt">\`</span>which <span class="at">-p</span> java<span class="dt">\`</span></span></code></pre></div>
<p>The -p switch shortens the output to just the path, without the
message "java is". On my system, this expands to the command I really
want to run.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ls</span> <span class="at">-l</span> /usr/bin/java</span></code></pre></div>
<p>Output:</p>
<pre><code>lrwxr-xr-x 1 root wheel 74B Sep 11 2018 /usr/bin/java -\&gt; /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java</code></pre>
<h2 id="history">History!</h2>
<p>The last symbol I want to mention is the exclamation mark, or bang
(!). This symbol allows you to execute any command in your command
history. To see a list of these commands, enter the following
command.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="bu">history</span></span></code></pre></div>
<p>Output:</p>
<pre><code>657 which -p java
658 ls -l \`which -p java\`
659 history</code></pre>
<p>You will be presented with a possibly-lengthy list of commands, with
the most recent at the end of the list. To execute any of them, simply
type the bang followed by the command number shown next to the
command.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ex">!657</span></span></code></pre></div>
<p>Output:</p>
<pre><code>which -p java
/usr/bin/java</code></pre>
<p>You can use the grep utility to search your history. For example,
here are all the find commands I ran writing this chapter, piped through
the uniq utility to get only unique commands.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="bu">history</span> <span class="dt">\|</span> grep find <span class="dt">\|</span> uniq</span></code></pre></div>
<p>Output:</p>
<pre><code>585 find \~ -name \*.pdf \&gt; \~/my-pdf-files.txt
586 find \~ -name \*.pdf \&gt; \~/my-pdf-files.txt &amp;
589 find \~ -name \*.pdf \&gt; \~/my-pdf-files.txt &amp; find \~ -name \*.mp3 \&gt; \~/my-mp3-files.txt &amp;
605 find \~ -name \*.pdf 2\&gt;/dev/null \| sort \&gt; \~/my-pdf-files.txt
606 find \~/Downloads/ -name \*.pdf 2\&gt;/dev/null \| sort \&gt; \~/my-pdf-files.txt
608 find \~/Downloads/ -name \*.pdf 2\&gt;/dev/null \| sort \&gt; \~/my-pdf-files.txt &amp;
663 history \| grep find \| uniq</code></pre>
<h3 id="ctrlr-search-history">Ctrl+R Search History</h3>
<p>As a bonus, in some shells, you can also use the keyboard
shortcut Ctrl+R to search your history interactively. To see this in
action, type Ctrl+R followed by the text of a command, for
example, find. The most recent match will appear. Continue
typing Ctrl+R to step backwards through the history. At any point, you
can stop by pressing Space, or the right or left arrow keys. You are
then free to edit the command, pressing Enter to execute it.
Press Ctrl+C to get out of the history without doing anything.</p>
<h3 id="summary">Summary</h3>
<p>Even though they are specifically targeted to *nix-based OSes, many
of these work in GitBash or similar on Windows.</p>
<p>I have only scratched the surface of the special symbols available in
many terminal shells.</p>
</body>
</html>
